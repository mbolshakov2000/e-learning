<template>
  <div>
    <div style="text-align: center; margin-top:20px;"><h2>Раздел 3. Основы SQL</h2></div><br><br>
    <div>
      <h3>Немного истории</h3><br>
      <p>Язык SQL (Structured Query Language). Произношение названия эс-кью-эл. Профессионалы часто произносят как [сиквел] -- по названию предшественника SQL языка SEQUEL. SQL расширяет реляционное исчисление на кортежах.
      Стандарт языка SQL86 (неофициально SQL1) ANSI X3.135-1986 под названием «Database Language SQL», принятый ISO и ANSI в 1986/1987 гг., описывает только запросы.  Сейчас не используется. 
      Промышленные СУБД основаны на следующих версиях:</p>
      <p>SQL2 (SQL-92) принят в 1992 г. Уровни соответствия стандарту: начальный (entry), средний (intermediate), полный (full).</p>
      <p>SQL3 (SQL-99) от 1999 года. Добавлены регулярки, рекурсия, триггеры, объектно-ориентированная модель, векторные типы.</p>
      <p>SQL-2003. Введена работа с XML-данными и оконные функции.   </p>
      <p>Последние расширения языка в стандартах SQL-2006, SQL-2008 и SQL-2011, SQL-2016. В основном это введение темпоральных данных, расширения многомерной и XML-моделей, JSON.</p>
      <h3>Подъязыки SQL, Базы, схемы, хранимые объекты </h3><br>
      <p>Выделяются следующие подъязыки:</p>
      <ul>
        <li>Язык определения данных, Data Definition Language (ЯОД или DDL). Задаёт структуру базы, пользователей, хранимые объекты и привилегии доступа к ним.</li>
        <li>Язык манипулирования данными (ЯМД). Он же Data Manipulation Language (DML). Вставляет, обновляет и удаляет данные и выполняет запросы к ним.</li>
        <li>Язык управления данными (транзакциями) Data Control Language (DCL).</li>
      </ul>
      <p>Хранимые объекты базы реляционного типа, образующие схему базы:</p>
      <ul>
        <li>Таблицы – в них хранятся данные.</li>
        <li>Представления (view) -- обычные и материализованные.</li>
        <li>Индексы (B* и побитовые) – могут ускорить доступ к данным.</li>
        <li>Триггеры – поддерживают процедурные ограничения целостности.</li>
        <li>Последовательности (sequence).</li>
        <li>Пользователи (user), их привилегии и роли.</li>
      </ul>
      <p>Имеется процедурная часть (PL/SQL). В ней добавляются хранимые объекты:</p>
      <ul>
        <li>Процедуры (procedure).</li>
        <li>Функции (function).</li>
        <li>Триггеры.</li>
        <li>Курсоры.</li>
      </ul>
      <p>Процедуры и функции могут группироваться в пакеты.</p>
      <br><h3>Язык DDL. Операторы определения объектов базы данных</h3><br>
      <p>Для каждого типа хранимых объектов базы (таблица, представление, последовательность, триггер, пользователь, но не курсор) существует “малый джентльменский” набор инструкций CREATE, ALTER, DROP (СОЗДАТЬ, ИЗМЕНИТЬ, УДАЛИТЬ), например:</p>
      <p>CREATE TABLE - создать таблицу</p>
      <p>ALTER TABLE - изменить таблицу</p>
      <p>DROP TABLE - удалить таблицу</p>
      <p>или</p>
      <p>CREATE VIEW - создать представление</p>
      <p>DROP VIEW - удалить представление</p>
      <p>ALTER VIEW – изменить представление</p>
      <p>Замечание: В стандарте предусмотрены еще инструкции для схем и доменов. Здесь они не приведены, так как домены в Oracle не реализуются.</p>
      <br><h3>Виды таблиц в Oracle</h3><br>
      <p>Heap organized tables - обычные таблицы (heap - куча), данные хранятся неупорядоченно.</p>
      <p>Index organized tables (IOT) - данные хранятся в упорядоченном виде, отсортированы по ПК. </p>
      <p>Nested tables (nested - вложенный) - это часть объектно-реляционных расширений для Oracle. Например, в схеме SCOTT таблицу EMP можно сделать вложенной в таблицу DEPT, реализуя связь предок – потомок (1:N).</p>
      <p>Temporary tables - врéменные таблицы – содержат данные сохраняющиеся во время транзакции или сессии.</p>
      <p>Object tables – объектные таблицы. Имеют сгенерированный системой REF (идентификатор объекта) для каждой строки. Объектные таблицы - это особый вариант heap-таблиц. Могут содержать вложенные таблицы. Интересны как пример эмуляции объектной модели в табличной.</p>
      <p>External tables – внешние таблицы. Данные в них хранятся в самой базе данных, а находятся в  файлах операционной системы. Можно запрашивать файл, находящийся вне базы данных, как если бы это была обычная таблица в базе данных. Внешние таблицы это инструмент для загрузки данных в базу.</p>
      <p>Кластерные таблицы.</p>
      <p>Многоверсионные (временные (исторические)) таблицы и flashback-технология.</p>
      <p>Таблицы PL/SQL.</p>
      <p>Секционированные таблицы.</p>
      <br><h3>Типы данных</h3><br>
      <p>Сначала рассмотрим числовые типы данных. </p>
      <p>Два основных типа NUMBER и FLOAT. </p>
      <p>NUMBER существует в трёх вариантах: </p>
      <p>NUMBER	-- без параметров;</p>
      <p>NUMBER(n)	-- мантисса в n десятичных позиций;</p>
      <p>NUMBER(n, m)     -- для чисел с фиксированной десятичной точкой. </p>
      <p>Гарантируется переносимость между любыми операционными системами, на которых ORACLE работает.</p>
      <p>Позволяет хранить:</p>
      <p>Положительные числа в диапазоне от 1 x 10-130 до 9.99...9 x x 10125 (до 38 значащих цифр).</p>
      <p>Отрицательные числа в диапазоне от  -1 x 10-130 до 9.99...99 x x 10125  (до 38 значащих цифр).</p>
      <p>Ноль.</p><br>
      <h3>Имена символьных типов данных</h3><br>
      <p>{CHAR [(size [BYTE | CHAR])]| VARCHAR2 (size [BYTE | CHAR])| NCHAR [(size)] | NVARCHAR2 (size)}</p>
      <p>Немного более подробное описание символьных типов.</p>
      <p>CHAR[(длина)] -- строки фиксированной длины от 1 до 2000 байт </p>
      <p>VARCHAR2 (длина) -- строки символов переменной длины от 1 до 4000 байт. Синоним VARCHAR.</p>
      <p>NCHAR(длина) и NVARCHAR2 (длина) – строки в национальной многобайтной кодировке </p>
      <p>Имена больших объектов четырех типов:</p>
      <p>{BLOB | CLOB | NCLOB | BFILE}</p>
      <p>Имена типов long и raw:</p>
      <p>{LONG | LONG RAW | RAW (size)}</p><br>
      <h3>Большие типы данных</h3><br>
      <p>BFILE — двоичный файл. Содержит локатор файла операционной системы расположенный вне базы данных. Это внешний объект</p>
      <p>BLOB — большой двоичный объект. Содержит локатор LOB, указывающий на большой двоичный объект, хранящийся в базе данных. Внутренний объект. Хранятся двоичные объекты, например, графические данные, видео- или звуковые файлы.</p>
      <p>CLOB — большой символьный объект. Содержит локатор LOB, указывающий на хранящийся в базе блок текстовых данных. Размер до 8 терабайт. Внутренний объект. Хранятся символьные объекты, например, документы.</p>
      <p>NCLOB — это LOB с поддержкой символов национальных языков (NLS). Cодержитлокатор LOB, указывающий на хранящийся в базе блок. Размер до 8 терабайт. Внутренний объект.</p>
      <p>RAW – аналог VARCHAR2, максимальный размер - 2000 байт.</p>
      <p>Столбец LOB может храниться не так, как базовая таблица. Можно, например, хранить данные таблицы и связанные с ней объекты LOB в разных местах.</p>
      <p>LONG для строк переменной длины-- максимальный размер до 2 Гб. Используется в словаре для хранения текстов. Столбцы типа LONG можно использовать в запросах и командах DML.</p>
      <p>LONG RAW, для двоичных данных или строк байтов -- максимальный размер до 2 Гб</p>
      <p>LONG и LONG RAW устаревшие типы используемые для обеспечения обратной совместимости; лучше заменить их на CLOB или BLOB</p>
      <p>В таблице может быть несколько столбцов CLOB, BLOB и BFILE, а столбец типов LONG или LONG RAW может быть только один. 
      Хотя в столбцах типа LONG и LONG RAW можно хранить большие объемы символьных и двоичных данных, максимальная длина соответствующих им переменных PL/SQL всего лишь 32 760 байт. Поэтому в PL/SQL лучше использовать вместо них типы VARCHAR2 и RAW.</p>
      <p>Значения типов LONG и LONG RAW, извлекаемые из базы данных и содержащие более 32 767 байт данных, не могут присваиваться переменным типа VARCHAR2 и RAW. Это крайне неудобное ограничение, из-за которого типы LONG и LONG RAW лучше вообще не применять.</p>
      <p>В описании типов и в функциях можно указывать размер в байтах VARCHAR2 (20 BYTE) и SUBSTR (&lt;string&gt;, 1, 20) </p>
      <p>и в символах VARCHAR2 (10 CHAR) and SUBSTR (&lt;string&gt;, 1, 10).</p>
      <p>Если вводимое значение имеет длину меньше указанной в определении типа CHAR, то происходит пополнение пробелами до этой длины. В столбце типа VARCHAR2 в этом случае сохранится ровно столько символов, сколько было введено.</p>
      <h3>Типы данных дата – время</h3><br>
      <p>{DATE | TIMESTAMP [(fractional_seconds_precision)] [WITH [LOCAL] TIME ZONE] INTERVAL YEAR [ (year_prec)] TO MONTH | INTERVAL DAY [ (day_precision) ] TO SECOND [(fractional_seconds_precision)]}</p>
      <p>Существует два вида типов даты – времени:</p>
      <p>DATE -- дата в диапазоне от 1 января 4712 г. до нашей эры до 31 декабря 9999 г. нашей эры; в дате хранится время с точностью до секунды.</p>
      <p>TIMESTAMP (точность) --значение года, месяца, дня, время в часах, минутах и секундах с точностью_в_долях_секунды. Диапазон точности от 0 до 9. Значение по умолчанию 6. </p>
      <p>Значение точности определяет число цифр в дробной части поля секунд.</p>
      <p>Существует два вида интервалов «год-месяц» и «день- время»:</p>
      <p>INTERVAL YEAR [(точность)] TO MONTH -- интервалы, содержащие годы и месяцы. Точность задает число цифр в поле лет. Необходимо указать целое значение в диапазоне от 0 до 4. По умолчанию значение 2.</p>
      <p>INTERVAL DAY [(точность_для_дней)] TO SECOND [(дробная_часть_секунд] -- интервалы, содержащие дни, часы, минуты и секунды. “Точность_для_дней” определяет число цифр в поле дней (от 0 до 9, по умолчанию 2 ). “Дробная_часть_секунд” задаёт точность в поле секунд (от 0 до 9, по умолчанию 6).</p>
      <h3>Маски форматов даты – времени</h3><br>
      <img src="../assets/36.png" style="width: 600px;"/><br><br>
      <h3>ROWID</h3><br>
      <p>ROWID это псевдостол­бец, являющийся уникальным идентификатором строки. Он уникален в рамках таблицы.</p>
      <p>Функцию SUBSTR можно использовать, чтобы разбить значение ROWID на четыре его  компоненты (объект, файл, блок и строку). Последняя компонента "строка" уникальна в пределах блока.</p>
      <p>Пример:</p>
      <p>SELECT ROWID, SUBSTR(ROWID,15,4) "FILE",</p>
      <p>       SUBSTR(ROWID,1,8) "BLOCK",</p>
      <p>       SUBSTR(ROWID,16,4) "ROW"</p>
      <p>       FROM emp;</p>
      <p>Значения ROWID записываются в системе счисления с основанием 64.</p>
      <p>Никогда не ссылайтесь на ROWID за пределами транзакции, в которой он был получен, т.к. значение ROWID для строки может изменяться.</p>
      <p>Пакет DBMS_ROWID позволяет создавать ROWID и получать информацию о ROWID из программ PL / SQL и инструкций SQL.</p>
      <img src="../assets/37.png" style="width: 600px;"/><br><br>
      <h3>Пример неправильного использования ROWID</h3><br>
      <p>Необходимо выбрать первые три записи из таблицы emp. Используем для этой цели ROWID.</p>
      <img src="../assets/38.png" style="width: 600px;"/><br><br>
      <p>Частный результат верен, но Решение неправильное. Поясняем это на примере, отличающемся типами CHAR с большой длиной, сравнимой с размером блока базы.</p>
      <p>CREATE TABLE chain_T (s1 char(2000), </p>
      <p>        s2 char(2000), s3 char(2000), s4 char(2000));</p>
      <p>INSERT INTO chain_T values ('A', 'A', 'A', 'A' );</p>
      <p>INSERT INTO chain_T values ('B', 'B', 'B', 'B');</p>
      <p>INSERT INTO chain_T values ('D', 'D', 'D', 'D');</p>
      <p>INSERT INTO chain_T values ('E', 'E', 'E', 'E');</p>
      <p>INSERT INTO chain_T values ('F', 'F', 'F', 'F');</p>
      <p>И из chain_T получим первые три записи тем же способом:</p>
      <img src="../assets/39.png" style="width: 600px;"/><br><br>
      <p>Удалим все строки и вновь их запишем. Повторим запрос.</p>
      <img src="../assets/40.png" style="width: 600px;"/><br>
      <p style="font-weight: bold;">Что получилось? Объясните результат.</p>
      <h3>Создание таблиц типа heap</h3>
      <img src="../assets/41.png" style="width: 600px;"/><br>
      <img src="../assets/42.png" style="width: 600px;"/><br><br>
      <p>Пояснение: в физических свойствах фраза deferred_segment_creation это SEGMENT CREATION DEFERRED/IMMEDIATE, где DEFERRED-означает, что сегмент создается при первой вставке INSERT.</p>
      <p>Почти все физические атрибуты для партиционированных таблиц могут быть заданы индивидуально для разделов (а могут и на уровне таблицы, тогда это влияет на все разделы).</p>
      <img src="../assets/43.png" style="width: 600px;"/><br><br>
      <p>PCTUSED нельзя указывать для индексно-организованных таблиц. PCTFREE+PCTUSED &lt;= 100. При малом значении PCTFREE и частых UPDATE вероятно, что строки будут перемещаться из текущего в другие блоки – миграция. Малое значение PCTFREE для экономии дискового пространства имеет смысл делать для архивных таблиц, или таблиц логов.</p>
      <img src="../assets/44.png" style="width: 400px;"/><br><br>
      <p>INITRANS – сколько слотов транзакций выделяется в блоке – от 1 до 255. По умолчанию 1. Слот транзакции – это место под маркер, который транзакция ставит в блок. Занимает около 23 байт.</p>
      <p>MAXSIZE – максимальный размер объекта (UNLIMITED не ограничено).</p>
      <p>MINEXTENTS – минимальное количество экстентов объекта.</p>
      <p>MAXEXTE NTS – используется только для табличных пространств управляемых словарём. Для вычисления первоначального размера используются параметры INITIAL, MINEXTENTS, NEXT и PCTINCREASE. При дальнейшем выделении новых экстентов они игнорируются.</p>
      <p>INITIAL – размер первого экстента объекта, в зависимости от allocation_type:</p>
      <p>UNIFORM – дефолтный размер экстента; другие – может быть выделено 64K, 1M, 8M, или 64M. Нельзя указывать в ALTER.</p>
      <p>NEXT – размер следующего выделяемого экстента:</p>
      <p>UNIFORM – игнорируется, значение берётся из табличного пространства; другие – Oracle сам вычисляет (заданное пользователем игнорируется)</p>
      <p>PCTINCREASE – на сколько % следующий экстент при выделении больше последнего (используется только для табличных  пространств управляемых словарём).</p>
      <h3>Создание врѐменных таблиц</h3><br>
      <p>Создание врѐменной таблицы уровня сессии (упрощённая версия).</p>
      <img src="../assets/45.png" style="width: 600px;"/><br><br>
      <p>Синтаксис создания врѐменной таблицы уровня сессии (ON COMMIT  PRESERVE ROWS) и уровня транзакции (ON COMMIT DELETE ROWS);</p>
      <p>CREATE GLOBAL TEMPORARY TABLE имя_таблицы</p>
      <p>    {column-definition [, column-definition ] *}</p>
      <p>    [ON COMMIT {DELETE | PRESERVE} ROWS];</p>
      <h3>Изменение таблиц</h3><br>
      <img src="../assets/46.png" style="width: 600px;"/><br><br>
      <p>Что делает с таблицей команда ALTER TABLE:</p>
      <ul>
        <li>изменение имени таблицы;</li>
        <li>изменение имени существующего поля;</li>
        <li>добавление нового поля;</li>
        <li>удаление существующего поля;</li>
        <li>изменение типа существующего поля;</li>
        <li>изменение выражение для виртуального поля;</li>
        <li>создание нового ограничения;</li>
        <li>удаление существующего ограничения;</li>
        <li>изменение имени существующего ограничения;</li>
        <li>отключение и включение действия ограничений;</li>
        <li>изменение параметров размещения таблицы и т.д.</li>
      </ul>
      <p>Основные подфразы:</p>
      <p>-- alter_table_properties – изменение свойств таблицы;</p>
      <p>-- column_clauses – добавление, удаление и изменение полей таблицы, в том числе переименование;</p>
      <p>-- constraint_clauses – добавление, изменение, переименование и удаление ограничений целостности;</p>
      <p>-- alter_table_partitioning – изменение способа партиционирования таблицы;</p>
      <p>-- move_table_clause – изменение атрибутов сегмента таблицы, в том числе перемещение в другое ТП;</p>
      <p>-- enable_disable_clause – включение/выключение ограничений целостности.</p>
      <p>Таблица должна быть в схеме пользователя, или пользователь должен иметь системную привилегию ALTER ANY TABLE. Можно:</p>
      <p>добавить, переопределить столбец (тип, размер, значение по умолчанию) или удалить его:</p>
      <p>ALTER TABLE имя_таблицы ADD имя_столбца тип_столбца [DEFAULT значение_по_умолчанию];</p>
      <p>ALTER TABLE имя_таблицы DROP COLUMN имя_столбца;</p>
      <p>ALTER TABLE имя_таблицы DROP (список_столбцов);</p>
      <p>сделать столбец неиспользуемым:</p>
      <p>ALTER TABLE имя_таблицы SET UNUSED COLUMN имя_столбца;</p>
      <p>ALTER TABLE имя_таблицы SET UNUSED (список_столбцов);</p>
      <p>Замечание: обратите внимание на то, что данные столбца, помеченного как неиспользуемый не удаляются; можно создать второй столбец с тем же именем, что у неиспользуемого; данные удаляются только после выполнения команды ALTER TABLE имя_таблицы DROP UNUSED COLUMNS</p>
      <p>Добавить ограничение целостности или изменить его свойства:</p>
      <p>ALTER TABLE имя_таблицы enable constaint имя_ограничения_целостности;--разрешить ограничение  </p>
      <p>ALTER TABLE имя_таблицы disable constaint имя_ограничения_целостности;--запретить ограничения</p>
      <p>ALTER TABLE имя_таблицы add constaint имя_ограничения_целостности; -- добавить ограничение</p>
      <p>ALTER TABLE имя_таблицы drop primary key; -- удаление ПК</p>
      <p>ALTER TABLE имя_таблицы drop constaint имя_ограничения_целостности; -- удалить ограничение </p>
      <p>ALTER TABLE имя_таблицы rename имя_старого_огранич. TO имя_нового_огранич; -- переименовать</p>
      <p>Примеры:</p>
      <p>Переименование таблицы ALTER TABLE "Все_заказы" RENAME TO "Все_ заказы_1";</p>
      <p>Переименование столбца ALTER TABLE "Клиент" RENAME column "Образование" TO "Степень";</p>
      <p>Установление значения по умолчанию ALTER TABLE "Клиент " MODIFY "Степень" DEFAULT 'отсутствует‘;</p>
      <h3>Комментарии</h3><br>
      <p>Могут создаваться комментарии к таблицам, столбцам, представлениям и моментальным снимкам. Комментарии к таблицам хранятся в представлениях:</p>
      <p>DBA_TAB_COMMENTS.</p>
      <p>Комментарии к столбцам хранятся в представлениях:</p>
      <p>DBA_COL_COMMENTS</p>
      <p>Комментарии к представлениям и материализованным представлениям хранятся в:</p>
      <p>DBA_MVIEW_COMMENTS, DBA_INDEXTYPE_COMMENTS, DBA_EDITION_COMMENTS.</p>
      <p>Как вы помните, вместо префикса DBA_ могут использоваться USER_ или ALL_.</p>
      <p>Добавление комментария на таблицу:</p>
      <p>COMMENT ON TABLE имя_таблицы is ‘текст_комментария’.</p>
      <p>Добавление комментария на столбец:</p>
      <p>COMMENT ON COLUMN имя_столбца is ‘текст_комментария’.</p>
      <p>Текст комментария может иметь размер до 4000 байт.</p>
      <p>Комментарий можно удалить из базы данных, установив его равным пустой строке (''). Например, COMMENT ON TABLE emp_new IS '';</p>
      <h3>Врéменные таблицы</h3>
      <p>В каких ситуациях они нужны:</p>
      <p>Создается достаточно большой объем врéменных данных, которые должны существовать только в период жизни транзакции или одной сессии. Затем они удаляются.</p>
      <p>Очень сложный запрос разбивается на несколько простых. Каждый из них формирует свою врéменную таблицу. Затем к ним обращаются. Такое кеширование промежуточных данных может повысить производительность.</p>
      <p>      В определении врéменных таблиц, существующих только в текущей транзакции добавляется фраза ON COMMIT DELETE ROWS:</p>
      <p>CREATE GLOBAL TEMPORARY TABLE … ON COMMIT DELETE ROWS;</p>
      <p>А в таблицах, существующих в течение сессии добавляется фраза ON COMMIT PRESERVE  ROWS:</p>
      <p>CREATE GLOBAL TEMPORARY TABLE … ON COMMIT PRESERVE ROWS;</p>
      <p>Для созданных врéменных таблиц сегменты выделяются только после первой вставки строки (первая команда INSERT или CREATE TABLE AS SELECT). Сегменты освобождаются после завершения транзакции, соответственно, сессии. Резервирование (backup) и восстановление (recovery) для врéменных таблиц невозможно.</p>
      <p>При откате транзакции данные врéменной таблицы теряются, но ее определение сохраняется. Если в рамках транзакции, использующей врéменную таблицу порождается несколько автономных транзакций, то они используют врéменную таблицу по очереди (последующая только после того как завершится предыдущая).</p>
      <p>Разрешается выполнять все команды DDL кроме TRUNCATE.</p>
      <p>Пример сессионной врéменной таблицы:</p>
      <p>CREATE GLOBAL TEMPORARY TABLE tt0</p>
      <p>(ename char(20),</p>
      <p>sal  number(5), usr char(10))</p>
      <p>ON COMMIT PRESERVE ROWS;</p>
      <p>Пример транзакционной врéменной таблицы:</p>
      <p>CREATE GLOBAL TEMPORARY TABLE tt1</p>
      <p>(ename char(20), sal  number(5), usr char(10))</p>
      <p>ON COMMIT DELETE ROWS;</p>
      <p>Ограничения на использование врéменных таблиц.</p>
      <ul>
        <li>Врéменные таблицы не могут использоваться в инструкциях: ALTER TABLE, CREATE INDEX, CREATE SYNONYM, CREATE TRIGGER, CREATE VIEW, GRANT, LOCK TABLE, RENAME, REVOKE.</li>
        <li>Временная таблица в Oracle не может быть партицирована, кластеризована, или быть организованной по индексу.</li>
        <li>Нельзя связывать внешние ключи с колонками временной таблицы</li>
        <li>Врéменная таблица не может включать вложенных таблиц (nested table)</li>
        <li>Нельзя использовать в описании временных таблиц фразы: LOB_storage,  storage_clause, или logging_clause</li>
        <li>Параллельные запросы во врéменных таблицах не поддерживаются </li>
        <li>Распределенные транзакции не могут работать с врéменными таблицами</li>
        <li>Сегментирование во врéменных таблицах не работает.</li>
      </ul><br>
      <br><h3>Контольные вопросы:</h3><br>
      <p>1. Какие существуют подъязыки SQL?</p>
      <p>2. Какие объекты образуют схему базы?</p>
      <p>3. Какие виды таблиц есть в Oracle?</p>
      <p>4. Какие типы данных есть в Oracle? В чём их отличие?</p>
      <p>5. Что такое ROWID?</p>
      <br><h3>Задание 3</h3><br>
      <p>1.	Создать и заполнить таблицы</p>
      <p>2.	Написать запросы, обосновав выбор их структуры</p>
      <p>3.	Если это возможно, привести несколько решений</p>
      <p>4.	Подтвердить правильность решений</p>
      <p>5.	Проанализировать планы исполнения</p>
      <br><h3>Пример</h3><br>
      <p>таблица product (продукт), поля: id, name (название), product_id (айди продукта)</p>
      <p>таблица order (порядок), поля: id, product_id, category_id (айди категории)</p>
      <p>таблица category (категория), поля: id, name (название)</p>
      <p>Запросы:</p>
      <p>(1) достать все товары вместе с их категориями, (2) достать товар 'Огурец' вместе с его категориями, (3) достать все товары из категории 'Овощи', (4) достать все товары, которые принадлежат более чем одной категории.</p>
      <h3>Решение:</h3>
      <a href = "https://disk.yandex.ru/d/CsC7iEpGvbflIg">Решение</a><br>
      <br><h3>Задания для самостоятельной работы:</h3><br>
      <p>2.	Схема</p>
      <p>таблица product (товар), поля: id, name (название), price (цена), date (дата), product_id (айди продукта)</p>
      <p>таблица purchase (покупка), поля: id, name (название), user_id (айди пользователя), product_id (айди продукта)</p>
      <p>таблица user (пользователь), поля: id, name (имя)</p>
      <p>Запросы:</p>
      <p>(1)	вывести пользователей вместе с их покупками, (2) вывести пользователей вместе с суммами всех их покупок, (3) найти суммарные покупки на сайте за определенный месяц, (4) найти суммарные покупки на сайте помесячно (то есть результат будет в таком виде: март 2010 — сумма1, апрель 2010 — сумма2, май 2010 — сумма3 и тд).</p><br>
      <p>3.	Схема</p>
      <p>таблица game (игра) поля: id, team1_id (айди 1й команды), team2_id (айдм 2й команды), date (дата), status (статус)</p>
      <p>таблица team (команда) поля: id, name (название)</p>
      <p>Запросы:</p>
      <p>Есть сайт с датами футбольных игр. В каждой игре нужно выводить дату игры, первую команду и вторую команду. После того, как игра прошла — нужно выводить еще и счет. Запросы: (1) получить все игры вместе с командами, (2) получить все игры с командами за текущий месяц, (3) получить все игры с командами за предыдущий месяц, (4) получить все сыгранные игры, (5) получить все несыгранные игры.</p>
    </div><br>
    <div>
      <iframe src="https://forms.yandex.ru/u/6560caabe010db355dea17f4/?iframe=1" frameborder="0" name="ya-form-6560caabe010db355dea17f4" width="650"></iframe>
    </div>
  </div>
</template>


<script>
export default {
  // eslint-disable-next-line
  name: 'Section3',
  props: {
      
  },
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style scoped>

</style>
